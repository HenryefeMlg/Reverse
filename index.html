<!DOCTYPE html><html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Henry Games Sound Studio</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    background-color: var(--theme-color, #222);
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    height: 100vh;
    overflow: hidden;
    transition: background-color 0.3s;
  }
  h1 {
    position: absolute;
    left: 10px;
    top: 10px;
    font-size: 1.4rem;
    font-weight: bold;
  }
  #settings-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 24px;
    cursor: pointer;
  }
  #settings-panel {
    position: absolute;
    top: 45px;
    right: 10px;
    background: rgba(0,0,0,0.8);
    padding: 10px;
    border-radius: 10px;
    display: none;
  }
  #controls {
    margin-top: 80px;
    display: flex;
    justify-content: center;
    gap: 15px;
  }
  button {
    background-color: rgba(255,255,255,0.1);
    border: 1px solid white;
    color: white;
    padding: 10px 18px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1rem;
    transition: 0.2s;
  }
  button:hover {
    background-color: rgba(255,255,255,0.3);
  }
  #reverse-btn {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
  }
  #visualizer {
    width: 100%;
    height: 150px;
    background: rgba(255,255,255,0.05);
  }
</style>
</head>
<body>
  <h1>Henry Games</h1>
  <div id="settings-btn">‚öôÔ∏è</div>
  <div id="settings-panel">
    <label>Tema Rengi:</label>
    <input type="color" id="theme-color-picker" />
  </div><canvas id="visualizer"></canvas>

  <div id="controls">
    <button id="record-btn">üéôÔ∏è Kaydet</button>
    <button id="stop-btn">‚èπÔ∏è Durdur</button>
    <button id="download-btn">üíæ ƒ∞ndir</button>
  </div>
  <button id="reverse-btn">üîÅ Tersten Oynat</button>  <script>
    const recordBtn = document.getElementById('record-btn');
    const stopBtn = document.getElementById('stop-btn');
    const downloadBtn = document.getElementById('download-btn');
    const reverseBtn = document.getElementById('reverse-btn');
    const visualizer = document.getElementById('visualizer');
    const canvasCtx = visualizer.getContext('2d');

    let mediaRecorder, audioChunks = [], audioBlob, audioUrl, audio;
    let audioContext, analyser, dataArray, source;

    recordBtn.onclick = async () => {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioChunks = [];
      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.start();

      audioContext = new AudioContext();
      source = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      source.connect(analyser);
      dataArray = new Uint8Array(analyser.frequencyBinCount);

      drawVisualizer();

      mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
      mediaRecorder.onstop = () => {
        audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        audioUrl = URL.createObjectURL(audioBlob);
        audio = new Audio(audioUrl);
      };
    };

    stopBtn.onclick = () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    };

    downloadBtn.onclick = () => {
      if (!audioBlob) return;
      const a = document.createElement('a');
      a.href = audioUrl;
      a.download = 'kayit.webm';
      a.click();
    };

    reverseBtn.onclick = async () => {
      if (!audioBlob) return;
      const arrayBuffer = await audioBlob.arrayBuffer();
      const context = new AudioContext();
      const buffer = await context.decodeAudioData(arrayBuffer);
      for (let i = 0; i < buffer.numberOfChannels; i++) {
        Array.prototype.reverse.call(buffer.getChannelData(i));
      }
      const reversedSource = context.createBufferSource();
      reversedSource.buffer = buffer;
      reversedSource.connect(context.destination);
      reversedSource.start(0);
    };

    function drawVisualizer() {
      requestAnimationFrame(drawVisualizer);
      if (!analyser) return;
      analyser.getByteFrequencyData(dataArray);
      canvasCtx.fillStyle = 'rgba(0,0,0,0.2)';
      canvasCtx.fillRect(0,0,visualizer.width,visualizer.height);
      const barWidth = (visualizer.width / dataArray.length) * 2.5;
      let x = 0;
      for(let i=0;i<dataArray.length;i++){
        const barHeight = dataArray[i];
        canvasCtx.fillStyle = `rgb(${barHeight+100},50,150)`;
        canvasCtx.fillRect(x, visualizer.height-barHeight/2, barWidth, barHeight/2);
        x += barWidth + 1;
      }
    }

    const settingsBtn = document.getElementById('settings-btn');
    const settingsPanel = document.getElementById('settings-panel');
    const colorPicker = document.getElementById('theme-color-picker');

    settingsBtn.onclick = () => {
      settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
    };

    colorPicker.oninput = e => {
      document.body.style.setProperty('--theme-color', e.target.value);
      localStorage.setItem('themeColor', e.target.value);
    };

    const savedColor = localStorage.getItem('themeColor');
    if (savedColor) {
      document.body.style.setProperty('--theme-color', savedColor);
      colorPicker.value = savedColor;
    }
  </script></body>
</html>
