<!DOCTYPE html><html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Henry Games Sound Studio 3.0</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    background-color: var(--theme-color, #222);
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    height: 100vh;
    overflow: hidden;
    transition: background-color 0.3s;
  }
  h1 {
    position: absolute;
    left: 10px;
    top: 10px;
    font-size: 1.4rem;
    font-weight: bold;
  }
  #settings-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 24px;
    cursor: pointer;
  }
  #settings-panel {
    position: absolute;
    top: 45px;
    right: 10px;
    background: rgba(0,0,0,0.8);
    padding: 10px;
    border-radius: 10px;
    display: none;
  }
  #controls {
    margin-top: 60px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
  }
  button {
    background-color: rgba(255,255,255,0.1);
    border: 1px solid white;
    color: white;
    padding: 10px 18px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1rem;
    transition: 0.2s;
    width: 180px;
  }
  button:hover {
    background-color: rgba(255,255,255,0.3);
  }
  #record-btn {
    font-size: 1.4rem;
    padding: 15px 20px;
    width: 200px;
  }
  #visualizer {
    width: 100%;
    height: 150px;
    background: rgba(255,255,255,0.05);
  }
</style>
</head>
<body>
  <h1>Henry Games</h1>
  <div id="settings-btn">‚öôÔ∏è</div>
  <div id="settings-panel">
    <label>Tema Rengi:</label>
    <input type="color" id="theme-color-picker" />
  </div><canvas id="visualizer"></canvas>

  <div id="controls">
    <button id="record-btn">üéôÔ∏è Kaydet</button>
    <button id="stop-btn">‚èπÔ∏è Durdur</button>
    <button id="reverse-btn">üîÅ Tersten Oynat</button>
    <button id="download-btn">üíæ WAV ƒ∞ndir</button>
  </div>  <script>
    let mediaRecorder, audioChunks = [], audioBuffer, audioBlob, audioUrl;
    let audioContext, analyser, dataArray, source;

    const recordBtn = document.getElementById('record-btn');
    const stopBtn = document.getElementById('stop-btn');
    const reverseBtn = document.getElementById('reverse-btn');
    const downloadBtn = document.getElementById('download-btn');
    const visualizer = document.getElementById('visualizer');
    const canvasCtx = visualizer.getContext('2d');

    const feedbackSound = new Audio('soundclip.wav');

    recordBtn.onclick = async () => {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioContext = new AudioContext();
      source = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      source.connect(analyser);
      dataArray = new Uint8Array(analyser.frequencyBinCount);
      drawVisualizer();

      const recorder = new MediaRecorder(stream);
      audioChunks = [];
      recorder.ondataavailable = e => audioChunks.push(e.data);
      recorder.onstop = async () => {
        const blob = new Blob(audioChunks);
        const arrayBuffer = await blob.arrayBuffer();
        const buffer = await audioContext.decodeAudioData(arrayBuffer);
        audioBuffer = buffer;
        audioBlob = encodeWAV(buffer);
        audioUrl = URL.createObjectURL(audioBlob);
      };
      mediaRecorder = recorder;
      mediaRecorder.start();
    };

    stopBtn.onclick = () => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    };

    reverseBtn.onclick = () => {
      if (!audioBuffer) return;
      for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
        Array.prototype.reverse.call(audioBuffer.getChannelData(i));
      }
      const context = new AudioContext();
      const source = context.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(context.destination);
      source.start(0);
    };

    downloadBtn.onclick = () => {
      if (!audioBlob) return;
      feedbackSound.currentTime = 0;
      feedbackSound.play();
      const a = document.createElement('a');
      a.href = audioUrl;
      a.download = 'kayit.wav';
      a.click();
    };

    function encodeWAV(audioBuffer) {
      const numOfChan = audioBuffer.numberOfChannels;
      const length = audioBuffer.length * numOfChan * 2 + 44;
      const buffer = new ArrayBuffer(length);
      const view = new DataView(buffer);

      writeUTFBytes(view, 0, 'RIFF');
      view.setUint32(4, 36 + audioBuffer.length * numOfChan * 2, true);
      writeUTFBytes(view, 8, 'WAVE');
      writeUTFBytes(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numOfChan, true);
      view.setUint32(24, audioBuffer.sampleRate, true);
      view.setUint32(28, audioBuffer.sampleRate * numOfChan * 2, true);
      view.setUint16(32, numOfChan * 2, true);
      view.setUint16(34, 16, true);
      writeUTFBytes(view, 36, 'data');
      view.setUint32(40, audioBuffer.length * numOfChan * 2, true);

      let offset = 44;
      for (let i = 0; i < audioBuffer.length; i++) {
        for (let ch = 0; ch < numOfChan; ch++) {
          let sample = audioBuffer.getChannelData(ch)[i] * 0x7fff;
          view.setInt16(offset, sample, true);
          offset += 2;
        }
      }

      return new Blob([view], { type: 'audio/wav' });
    }

    function writeUTFBytes(view, offset, string){
      for (let i = 0; i < string.length; i++){
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    function drawVisualizer() {
      requestAnimationFrame(drawVisualizer);
      if (!analyser) return;
      analyser.getByteFrequencyData(dataArray);
      canvasCtx.fillStyle = 'rgba(0,0,0,0.2)';
      canvasCtx.fillRect(0,0,visualizer.width,visualizer.height);
      const barWidth = (visualizer.width / dataArray.length) * 2.5;
      let x = 0;
      for(let i=0;i<dataArray.length;i++){
        const barHeight = dataArray[i];
        canvasCtx.fillStyle = `rgb(${barHeight+100},50,150)`;
        canvasCtx.fillRect(x, visualizer.height-barHeight/2, barWidth, barHeight/2);
        x += barWidth + 1;
      }
    }

    const settingsBtn = document.getElementById('settings-btn');
    const settingsPanel = document.getElementById('settings-panel');
    const colorPicker = document.getElementById('theme-color-picker');

    settingsBtn.onclick = () => {
      settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
    };

    colorPicker.oninput = e => {
      document.body.style.setProperty('--theme-color', e.target.value);
      localStorage.setItem('themeColor', e.target.value);
    };

    const savedColor = localStorage.getItem('themeColor');
    if (savedColor) {
      document.body.style.setProperty('--theme-color', savedColor);
      colorPicker.value = savedColor;
    }
  </script></body>
</html>
